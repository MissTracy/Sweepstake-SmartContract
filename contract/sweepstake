// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts-upgradeable/proxy/utils/Initializable.sol";
import "@openzeppelin/contracts-upgradeable/utils/ReentrancyGuardUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/access/OwnableUpgradeable.sol";
import "@openzeppelin/contracts-upgradeable/proxy/utils/UUPSUpgradeable.sol";
import "@chainlink/contracts/src/v0.8/vrf/interfaces/VRFCoordinatorV2Interface.sol";

contract Sweepstake is Initializable, ReentrancyGuardUpgradeable, OwnableUpgradeable, UUPSUpgradeable {
    uint256 public roundId;
    uint256 public roundStart;
    uint256 public constant ROUND_DURATION = 10 minutes;
    uint256 public constant MIN_CONTRIBUTION = 0.01 ether;

    address payable[] public participants;
    mapping(address => bool) public hasJoined;
    mapping(uint256 => address payable) public rewardHistory;

    // VRF state
    VRFCoordinatorV2Interface public coordinator;
    bytes32 public keyHash;
    uint64 public subscriptionId;
    uint32 public callbackGasLimit;
    uint256 private vrfRequestId;

    // Events
    event ParticipantJoined(address indexed participant, uint256 amount);
    event RewardDistributed(address indexed recipient, uint256 amount, uint256 roundId);
    event NewRoundStarted(uint256 roundId);
    event RandomnessRequested(uint256 requestId);

    function initialize(
        address initialOwner,
        address _coordinator,
        bytes32 _keyHash,
        uint64 _subscriptionId,
        uint32 _callbackGasLimit
    ) external initializer {
        __ReentrancyGuard_init();
        __Ownable_init(initialOwner);
        __UUPSUpgradeable_init();

        // Chainlink VRF setup
        coordinator = VRFCoordinatorV2Interface(_coordinator);
        keyHash = _keyHash;
        subscriptionId = _subscriptionId;
        callbackGasLimit = _callbackGasLimit;

        roundId = 1;
        roundStart = block.timestamp;
        emit NewRoundStarted(roundId);
    }

    modifier roundOpen() {
        require(block.timestamp < roundStart + ROUND_DURATION, "Round closed");
        _;
    }

    function joinPool() external payable roundOpen nonReentrant {
        require(!hasJoined[msg.sender], "Already joined");
        require(msg.value >= MIN_CONTRIBUTION, "Min ETH not met");

        hasJoined[msg.sender] = true;
        participants.push(payable(msg.sender));
        emit ParticipantJoined(msg.sender, msg.value);
    }

    function requestRandomWinner() external onlyOwner {
        require(block.timestamp >= roundStart + ROUND_DURATION, "Round active");
        require(participants.length > 0, "No participants");

        vrfRequestId = coordinator.requestRandomWords(
            keyHash,
            subscriptionId,
            3,
            callbackGasLimit,
            1
        );

        emit RandomnessRequested(vrfRequestId);
    }

    function fulfillRandomWords(uint256, uint256[] memory randomWords) internal {
        uint256 index = randomWords[0] % participants.length;
        address payable winner = participants[index];

        uint256 prize = address(this).balance;
        (bool success, ) = winner.call{value: prize}("");
        require(success, "ETH transfer failed");

        rewardHistory[roundId] = winner;
        emit RewardDistributed(winner, prize, roundId);

        for (uint256 i; i < participants.length;) {
            hasJoined[participants[i]] = false;
            unchecked { ++i; }
        }
        delete participants;

        roundId++;
        roundStart = block.timestamp;
        emit NewRoundStarted(roundId);
    }

    function startNewRound() external onlyOwner {
        // Clear participants from previous round
        for (uint256 i = 0; i < participants.length; ) {
            hasJoined[participants[i]] = false;
            unchecked { ++i; }
        }
        delete participants;

        // Start a new round
        roundId++;
        roundStart = block.timestamp;

        emit NewRoundStarted(roundId);
    }

    function getParticipants() external view returns (address payable[] memory) {
        return participants;
    }

    function getPoolBalance() external view returns (uint256) {
        return address(this).balance;
    }

    function getRewardRecipient(uint256 _roundId) external view returns (address payable) {
        return rewardHistory[_roundId];
    }

    function _authorizeUpgrade(address) internal override onlyOwner {}
}
